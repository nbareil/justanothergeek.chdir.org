<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Syscall on Just Another Geek</title>
    <link>https://justanothergeek.chdir.org/categories/syscall/</link>
    <description>Recent content in Syscall on Just Another Geek</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Mar 2010 14:10:00 +0000</lastBuildDate>
    
	<atom:link href="https://justanothergeek.chdir.org/categories/syscall/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SECCOMP as a Sandboxing solution ?</title>
      <link>https://justanothergeek.chdir.org/2010/03/SECCOMP-as-a-Sandboxing-solution/</link>
      <pubDate>Thu, 04 Mar 2010 14:10:00 +0000</pubDate>
      
      <guid>https://justanothergeek.chdir.org/2010/03/SECCOMP-as-a-Sandboxing-solution/</guid>
      <description>Sandboxing technology? SECCOMP is a Linux feature introduced in 2.6.23 (2005) by Andrea Arcangeli, initially designed for grid computing applications. The idea was to sell CPU times to the public by running untrusted binaries.
When a process goes into SECCOMP mode, it can only do 4 syscalls: read, write, _exit and sigreturn. The kernel will enforce this limitation by killing (by a SIGKILL signal) the process if an unauthorized system call is made.</description>
    </item>
    
    <item>
      <title>How system calls work on recent Linux x86 glibc</title>
      <link>https://justanothergeek.chdir.org/2010/02/How-system-calls-work-on-recent-Linux-x86-glibc/</link>
      <pubDate>Sat, 20 Feb 2010 22:11:00 +0000</pubDate>
      
      <guid>https://justanothergeek.chdir.org/2010/02/How-system-calls-work-on-recent-Linux-x86-glibc/</guid>
      <description>This post explains how system calls are implemented on recent Linux system. It covers only the x86_32 platform, on a recent Linux kernel and GNU Libc (where recent means &amp;ldquo;released after 2005&amp;rdquo;).
Processor facility for making syscall On x86, userspace processes run in ring 3, while the kernel is in ring 0. Only the kernel can do the interface between the resources and the processes.
A resource can be an access to a hardware device, a kernel object or any kind of IPC.</description>
    </item>
    
  </channel>
</rss>