<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>How system calls work on recent Linux x86 glibc - Just Another Geek</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="How system calls work on recent Linux x86 glibc" />
<meta property="og:description" content="This post explains how system calls are implemented on recent Linux system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://justanothergeek.chdir.org/2010/02/How-system-calls-work-on-recent-Linux-x86-glibc/" /><meta property="article:published_time" content="2010-02-20T22:11:00&#43;00:00"/>
<meta property="article:modified_time" content="2010-02-20T22:11:00&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How system calls work on recent Linux x86 glibc"/>
<meta name="twitter:description" content="This post explains how system calls are implemented on recent Linux system."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://justanothergeek.chdir.org/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://justanothergeek.chdir.org/css/main.css" />

	
		<script src="https://justanothergeek.chdir.org/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
	<h1 class="site-title"><a href="https://justanothergeek.chdir.org/">Just Another Geek</a></h1>
	<div class="site-description"><nav class="nav social">
			<ul class="flat"></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">20</span>
							<span class="rest">Feb 2010</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">How system calls work on recent Linux x86 glibc</h1>
				</div>
			</div>
					
			<div class="markdown">
				

<p>This post explains how system calls are implemented on recent Linux
system. It covers only the x86_32 platform, on a recent Linux kernel
and GNU Libc (where recent means &ldquo;released after 2005&rdquo;).</p>

<h3 id="processor-facility-for-making-syscall">Processor facility for making syscall</h3>

<p>On x86, userspace processes run in ring 3, while the kernel is in ring
0. Only the kernel can do the interface between the resources and the
processes.<br />
A resource can be an access to a hardware device, a kernel object or any
kind of IPC. In other words, each time it is needed to do such action,
the userspace application has to make a request to the kernel; this is
what we call a system call (syscall), basically, this is the transition
from a ring to another one.<br />
Historically, on Linux and x86, the best known method for performing a
syscall is to generate an interruption (the classic <code>int $0x80</code>
instruction) which is trapped by the kernel and then processed.<br />
It was the most efficient way until the Pentium 4 where it became the
slowest mechanism available. The best method became the
<code>sysenter/sysexit</code> instructions on <code>x86_32</code> which is usable the same way
than with the interrupt. For instance, here is a simple call to
<code>_exit(42)</code>:</p>

<pre><code>mov $1, %eax   ;; __NR_exit = 1
mov $42, %ebx  ;; status = 42
sysenter       ;; perform the syscall!
</code></pre>

<p>On AMD64, a similar mechanism exists: <code>syscall/sysret</code> which is, by
the way, known to be a better interface and more performant than its
Intel equivalent. Anyway.</p>

<p>Usually, except shellcodes, syscalls are generated by the libc and,
depending on the processor, using one solution or another can have
strong impact on performances : if the libc keeps using <code>int $0x80</code> even
on modern CPU, the performances will be bad.</p>

<p>The problem is that, usually, Linux distributions provide only one
compiled version of the libc: it has to run equally well on all CPU
versions (486, 586 or 686). Thus, there was a need for an abstraction
layer called by the libc which would choose the best mechanism at
runtime.<br />
This is done by the kernel: it is compiled with all syscalls mechanisms
and selects the best one at boot time. Once a method is chosen, it
exposes a function to userspace calling directly the selected methods.
This way of exposing page is called a Virtual Dynamical Shared Object,
or VDSO.<br />
From the other side, in the libc, making a system call is just a matter
of calling a VDSO&rsquo;s function, without knowing if a historical interrupt
will be done or a <code>sysenter</code>.<br />
If we rewrite our previous snippet and make it use the vdso:<br />
    movl $1, %eax   ;; __NR_exit = 1
    movl $42, %ebx   ;; status   = 42
    call *%gs:0x10  ;; Here, the offset (0x10) is platform-dependent
                    ;; The memory page %gs:0x10 is located in the VDSO</p>

<h3 id="virtual-dynamic-shared-object">Virtual Dynamic Shared Object</h3>

<p>A Virtual Dynamic Shared Object (VDSO) is a page maintained by the
kernel and exposed to userspace by mapping this page into its address
space. For instance:<br />
    $ cat /proc/self/maps
    08048000-08051000 r-xp 00000000 fd:01 14450888   /bin/cat
    08051000-08052000 rw-p 00009000 fd:01 14450888   /bin/cat
    083d7000-083f8000 rw-p 00000000 00:00 0          [heap]
    b7475000-b7633000 r&ndash;p 00000000 fd:01 592041     /usr/lib/locale/locale-archive
    b7633000-b7634000 rw-p 00000000 00:00 0
    b7634000-b7775000 r-xp 00000000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
    b7775000-b7777000 r&ndash;p 00141000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
    b7777000-b7778000 rw-p 00143000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
    b7778000-b777b000 rw-p 00000000 00:00 0
    b7794000-b7796000 rw-p 00000000 00:00 0
    b7796000-b7797000 r-xp 00000000 00:00 0          [vdso]
    b7797000-b77b3000 r-xp 00000000 fd:01 2818106    /lib/ld-2.10.2.so
    b77b3000-b77b4000 r&ndash;p 0001b000 fd:01 2818106    /lib/ld-2.10.2.so
    b77b4000-b77b5000 rw-p 0001c000 fd:01 2818106    /lib/ld-2.10.2.so
    bfafd000-bfb12000 rw-p 00000000 00:00 0          [stack]</p>

<p>Here, the VDSO is one page long (4096 bytes). It contains the syscall
abstraction interface, but also some shared variables (low level
information like rdtsc counter, real-time timer, stack canary, etc.)<br />
The selection of the right syscall method is done by the Linux kernel in
<a href="http://lxr.linux.no/#linux+v2.6.32/arch/x86/vdso/vdso32-setup.c"><code>arch/x86/vdso/vdso32-setup.c</code></a>
in the <code>sysenter_setup</code> function (which is called very early at kernel
initialization by <code>identify_boot_cpu()</code>).<br />
    int __init sysenter_setup(void)
    {
        void *syscall_page = (void *)get_zeroed_page(GFP_ATOMIC);
        const void *vsyscall;
        size_t vsyscall_len;</p>

<pre><code>    vdso32_pages[0] = virt_to_page(syscall_page);

#ifdef CONFIG_X86_32
    gate_vma_init();
#endif

    if (vdso32_syscall()) {
        vsyscall = &amp;vdso32_syscall_start;
        vsyscall_len = &amp;vdso32_syscall_end - &amp;vdso32_syscall_start;
    } else if (vdso32_sysenter()){
        vsyscall = &amp;vdso32_sysenter_start;
        vsyscall_len = &amp;vdso32_sysenter_end - &amp;vdso32_sysenter_start;
    } else {
        vsyscall = &amp;vdso32_int80_start;
        vsyscall_len = &amp;vdso32_int80_end - &amp;vdso32_int80_start;
    }

    memcpy(syscall_page, vsyscall, vsyscall_len);
    relocate_vdso(syscall_page);

    return 0;
}
</code></pre>

<p>The implementation of the <code>sysenter</code> method is in
<a href="http://lxr.linux.no/#linux+v2.6.32/arch/x86/vdso/vdso32/sysenter.S"><code>arch/x86/vdso/vdso32/sysenter.S</code></a>.
The routine called by the libc (with the <code>call *%gs:0x10</code>) is named
<code>__kernel_vsyscall</code>:<br />
      __kernel_vsyscall:
      .LSTART_vsyscall:
          push %ecx
      .Lpush_ecx:
          push %edx
      .Lpush_edx:
          push %ebp
      .Lenter_kernel:
          movl %esp,%ebp
          sysenter
        /* 7: align return point with nop&rsquo;s to make disassembly easier */
        .space 7,0x90</p>

<pre><code>    /* 14: System call restart point is here! (SYSENTER_RETURN-2) */
    jmp .Lenter_kernel
    /* 16: System call normal return point is here! */
VDSO32_SYSENTER_RETURN: /* Symbol used by sysenter.c via vdso32-syms.h */
    pop %ebp
.Lpop_ebp:
    pop %edx
.Lpop_edx:
    pop %ecx
.Lpop_ecx:
    ret
</code></pre>

<p>Linus Torvalds is the proud owner of this code because he managed to
handle the system call restarting thanks to a CPU particularity: when
the kernel is done with a system call and want to give the control back
to the process, it just have to perform the <code>sysexit</code> instruction.<br />
Prior to that, the kernel specified to the CPU that at <code>sysexit</code>, it has
to jump to a specific static address. This address is the
<code>VDSO32_SYSENTER_RETURN</code> label saw in the previous routine.</p>

<p></div></p>

			</div>

			<div class="tags">
				
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-13174242-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>
</html>
