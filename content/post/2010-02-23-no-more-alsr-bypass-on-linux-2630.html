---
categories:
- linux
- kernel
- exploit
date: "2010-02-23T12:26:00Z"
title: No more ASLR bypass on Linux 2.6.30
---

<div class='post'>
While trying to exploit a local setuid application, I had the
unhappiness (as an attacker) to see that the security of the ASLR
Linux kernel has increased, removing a whole method of
exploitation. But let's begin from the start:
<br />
The minimalist vulnerable example could be this <code>vuln.c</code>:
<br />
<pre class="src src-c"><span style="color: #7a378b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #7a378b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>

<span style="color: forestgreen;">int</span> <span style="color: blue;">main</span>( <span style="color: forestgreen;">int</span> <span style="color: sienna;">argc</span>, <span style="color: forestgreen;">char</span> *<span style="color: sienna;">argv</span>[] )
{
        <span style="color: forestgreen;">char</span> <span style="color: sienna;">buf</span>[4];

        printf(<span style="color: #8b2252;">"%#p\n"</span>, &amp;buf);
        strcpy( buf, argv[1] );
        <span style="color: #a020f0;">return</span> 0;
}
</pre>
Because of the <i>Address Space Layout Randomization</i> (ASLR), this bug
is tough to exploit: if the binary is compiled with the right
options and the kernel is configured to fully randomize the address
space, it becomes impossible to guess where the buffer is, nor the
location of the functions' libraries.
<br />
But there was a trick (firstly published by <a href="http://www.amazon.com/Hacking-Art-Exploitation-Jon-Erickson/dp/1593271441">Jon Erickson in his book</a>):
the randomization is computed at <code>exec*()</code> time, the seed used to
generate the entropy was rekeyed every X milliseconds with the PID
and the <code>jiffies</code> variable (which is the number of clock
interruptions since the boot), it was known to be cryptographically
weak but it was good enough for daemons: remotely, it's not possible
to guess either the PID or <code>jiffies</code> (except in case of a format
string vulnerability or an information leak).
<br />
But locally, the entropy was just useless: a minimalistic process
which would just <code>exec*()</code> another one would get the same memory
layout because both program has the same PID and the jiffies would
not be updated.
<br />
Practically, even on a fully randomized system, it was possible to
guess the addresses, here is the minimalistic program just printing
the address of its buffer and executing the vulnerable binary (which
itself prints its buffer address):
<br />
<pre class="src src-c"><span style="color: #7a378b;">#include</span> <span style="color: #8b2252;">&lt;unistd.h&gt;</span>

<span style="color: forestgreen;">int</span> <span style="color: blue;">main</span>(<span style="color: forestgreen;">int</span> <span style="color: sienna;">argc</span>, <span style="color: forestgreen;">char</span> **<span style="color: sienna;">argv</span>) {
        <span style="color: forestgreen;">char</span> <span style="color: sienna;">dummy</span>[4] = <span style="color: #8b2252;">"AAA"</span>;

        printf(<span style="color: #8b2252;">"%#p\n"</span>, dummy);
        execl(<span style="color: #8b2252;">"./vuln"</span>, dummy, <span style="color: darkcyan;">NULL</span>);
}
</pre>
The following Python code based on <code>expect</code> runs the exploit
multiple times and compute the differences between the addresses of
<code>./vuln</code> and <code>./exploit</code> :
<br />
<pre class="src src-python"><span style="color: firebrick;">#! /usr/bin/python
</span>
<span style="color: #a020f0;">import</span> pexpect

<span style="color: #a020f0;">while</span> <span style="color: #a020f0;">True</span>:
    child = pexpect.spawn(<span style="color: #8b2252;">'./exploit'</span>)
    child.sendeof()

    a=<span style="color: #7a378b;">int</span>(child.readline()[:-2], 16)
    b=<span style="color: #7a378b;">int</span>(child.readline()[:-2], 16)

    <span style="color: #a020f0;">print</span> <span style="color: #8b2252;">'offset=%#x'</span> % (b-a)
    child.expect(pexpect.EOF)
</pre>
Let's do it:
<br />
<pre>lenny32:/tmp$ uname -a
Linux lenny32 2.6.26-2-686 #1 SMP Wed Aug 19 06:06:52 UTC 2009 i686 GNU/Linux
lenny32:/tmp$ cat /proc/sys/kernel/randomize_va_space
2
lenny32:/tmp$ ./guess_offset
offset=0x10
offset=0x148160
offset=0x10
offset=0x10
offset=0x10
offset=0x1bf9d0
offset=0x10
offset=0x1d91f0
offset=0x10
offset=-0x2ba2a0
offset=0x3d050
offset=0x10
offset=0x10
offset=0x10
offset=-0x19a990
offset=0x10
offset=0x10
offset=0x10
offset=0x10
offset=0x10
offset=0x10
offset=0x10
KeyboardInterrupt
</pre>
Most of the time, we can see that the offset is equals to <code>0x10</code>,
great! But on a 2.6.32 kernel, the result is totally different:
<br />
<pre>$ ./guess_offset
offset=0x4fddb0
offset=0x69f330
offset=0x137e40
offset=0x6b49f0
offset=0x407600
offset=0x14cf50
offset=0x3f4930
offset=0x4d0f80
offset=0x107d20
offset=0x1969b0
offset=0x1ae360
offset=0x409b30
</pre>
In other words, it's now impossible to guess the address space
layout with this method.
<br />
When was patched the function in charge of the randomness,
<a href="http://lxr.linux.no/linux+v2.6.32/+code=secure_ip_id"><code>get_random_int()</code></a>? Let's use <code>git-blame</code> in order to annotate each
source line with its modification date and commit: 
<br />
<pre>
% git blame -L 1688,1709 drivers/char/random.c
8a0a9bd4 DEFINE_PER_CPU(__u32 [4], get_random_int_hash);
^1da177e <span style="color: forestgreen;">unsigned</span> <span style="color: forestgreen;">int</span> <span style="color: blue;">get_random_int</span>(<span style="color: forestgreen;">void</span>)
^1da177e {
8a0a9bd4  <span style="color: #a020f0;">struct</span> <span style="color: forestgreen;">keydata</span> *<span style="color: sienna;">keyptr</span>;
8a0a9bd4  <span style="color: forestgreen;">__u32</span> *<span style="color: sienna;">hash</span> = get_cpu_var(get_random_int_hash);
8a0a9bd4  <span style="color: forestgreen;">int</span> <span style="color: sienna;">ret</span>;
8a0a9bd4 
8a0a9bd4  keyptr = get_keyptr();
26a9a418  hash[0] += current-&gt;pid + jiffies + get_cycles();
8a0a9bd4 
8a0a9bd4  ret = half_md4_transform(hash, keyptr-&gt;secret);
8a0a9bd4  put_cpu_var(get_random_int_hash);
8a0a9bd4 
8a0a9bd4  <span style="color: #a020f0;">return</span> ret;
^1da177e }
^1da177e 
</pre>

<p>
Arg! It was patched in commit <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=8a0a9bd4db63bc45e3017bedeafbd88d0eb84d02"><code>8a0a9bd4</code></a> by Linus Torvalds in
response to <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2009-3238">CVE2009-3238</a> in May 2009. The first released kernel
carrying this patch is the 2.6.30 in June 2009.
</p>

<p>
Actually, I'm not aware of any generic trick to achieve the same
goal (now that <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=f83ce3e6b02d5e48b3a43b001390e2b58820389d">information leaks on /proc entries have been fixed too</a>).
</p></div>
