---
categories:
- ssl
- vulnerability
- exploit
date: "2010-03-25T11:22:00Z"
title: 'CVE-2010-0740: Record of death vulnerability in OpenSSL'
---

<div class='post'>
<p>A new vulnerability (CVE-2010-0740) was found in OpenSSL, affectionately called
"<a href="http://www.openssl.org/news/secadv_20100324.txt">Record of death</a>" (in reference to the <a href="http://insecure.org/sploits/ping-o-death.html">ping of death</a> vulnerability
back in 1996) was fixed by the patch below:
</p>

<pre>
--- ssl/s3_pkt.c 24 Jan 2010 13:52:38 -0000 1.57.2.9
+++ ssl/s3_pkt.c 24 Mar 2010 00:00:00 -0000
@@ -291,9 +291,9 @@
  if (version != s->version)
   {
   SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);
-  /* Send back error using their
-   * version number :-) */
-  s->version=version;
+                if ((s->version & 0xFF00) == (version & 0xFF00))
+                 /* Send back error using their minor version number :-) */
+   s->version = (unsigned short)version;
   al=SSL_AD_PROTOCOL_VERSION;
   goto f_err;
   }
</pre>



<p>
<a href="http://natisbad.org">Arno</a> and myself had a look on this vuln, but at a glance, it's hard to understand the consequences of theses two modifications:
</p>
<ul>
<li>
Comparison of the server version and the packet version

</li>
<li>
Use of cast for the assignment.

</li>
</ul>

<p>The latter is the interesting part. <code>s-&gt;version</code> is declared as a
<code>int</code> (32 bits signed value on <code>x86</code>) and <code>version</code> is a <code>short</code> (16
bits signed value on <code>x86</code>).
</p>
<p>
When doing the following assignment:
</p>



<pre>
int i_version;
short s_version;

i_version = s_version;
</pre>



<p>
What are the problems? On <code>x86</code>, <code>i_version</code> is big enough to store
<code>s_version</code> so there is no truncation or overflow issues. However,
theses two variables are signed and the C has the following rule:
</p>
<blockquote>

<p><em>Conversion of an operand value to a compatible type causes no
change to the value or the representation.</em>
</p>
</blockquote>


<p>
In other words:
</p>

<pre>
short s;
int i;

s = -1;
i = s; /* i must be equal to -1 */
</pre>
  
<p>
To do this, the compiler has to perform a <i>sign extension</i>, which
means that if the short value was negative, its integer value must
stays negative.
</p>
<p>
Internally, the most significant bit (msb) of the short variable
will be propagated in the integer variable for the "upper                                                                                                                                                                                                                                                                       
bits". Examples:
</p>

<pre>
  |--------+-----+--------------|                                                                                                                                                                                                                                                                                               
  |  short | msb | integer      |                                                                                                                                                                                                                                                                                               
  |--------+-----+--------------|                                                                                                                                                                                                                                                                                               
  | 0x0000 |   0 | 0x<span style="color: red">0000</span>0000   |                                                                                                                                                                                                                                                                                               
  | 0x7000 |   0 | 0x<span style="color: red">0007</span>0000   |                                                                                                                                                                                                                                                                                               
  | 0x8000 |   1 | 0x<span style="color: red">ffff</span>0000   |                                                                                                                                                                                                                                                                                               
  | 0xffff |   1 | 0x<span style="color: red">ffff</span>ffff   |  
  |--------+-----+--------------|                                                                                                                                                                                                                                                                                               
</pre>

<p>
So if <code>version >= 0x8000</code>, <code>s->version</code> will have a value <code>&gt;= 0xffff0000</code> (a big negative value).
</p>

<p>
According to the advisory, this bug can cause
a crash of an OpenSSL end-point due to a read attempt at NULL.<br />
The OpenSSL code uses extensively indirect function pointers for callbacks so it is hard to
follow the code path without spending some time, so I cannot confirm neither my hypothesis
nor the impact of the bug.
</p></div>
