---
categories:
- kernel
- security
date: "2011-01-03T22:48:00Z"
title: Linux Security, one year later...
---

<div class='post'>
<p>
  This post (tries to) describe what happened in 2010 about GNU/Linux security. What
  this post is not is a long list of vulnerabilities, there are <a href="http://xor.wordpress.com/">some people doing it way better</a> that
  me.
</p>

<p>
  The first part of this post is dedicated to new vulnerability classes where the
  second one focuses on the defensive side, analyzing improvements made to the
  Linux kernel.  Before closing this post, some selected quotes will be presented,
  pointing the finger at some of the Linux failures.
</p>

<p>
  This post being (very) long and being syndicated by a few "planets", I will cut this post on my feed, even if I know
  that <a href="http://sid.rstack.org/blog/index.php/392-ca-m-enerve">a lot of
  people dislikes this behavior</a>.
</p>

<a name='more'></a>

<h1>Yang: New attacks, new vulnerability classes</h1>

<p>
  Thanks to the generalization of userspace hardening in common Linux
  distribution (packages compiled with most of the protection options
  like
  <a href="http://www.trl.ibm.com/projects/security/ssp/"><code>stack-protector</code></a>, 
  <a href="http://en.wikipedia.org/wiki/Position-independent_code"><code>PIE</code></a>,
  <a href="http://gcc.gnu.org/ml/gcc-patches/2004-09/msg02055.html"><code>FORTIFY_SOURCE</code></a>,
  writing of SELinux rules), vulnerability researchers had to
  find a milder field : the kernel.
</p>

<p>
  In 2009, Tavis Ormandy and <a href="http://www.cr0.org/">Julien Tinnes</a> made
  a lot of noise with their <i>NULL pointer dereference</i> vulnerabilities.<br />
  Pro-active measures were developed to mitigate this kind of bug but the play of
  the cat and mouse never stopped to to bypass theses protections.
</p>


<h2>Bypassing of <code>mmap_min_addr</code></h2>

<p>
  Let's remind that this protection consists of denying the allocation of memory
  pages below a limit, called <code>mmap_min_addr</code>
  (<code>/proc/sys/vm/mmap_min_addr</code>). Thus, it prevents an attacker to drop
  off his shellcode at address 0-or-something and then triggering the NULL pointer
  dereference.
</p>

<p>
  A lot of methods were found in 2009 to bypass this restriction (<i>Update: as pointed by Dan Rosenberg, the first 
  one is not a <code>mmap_min_addr bypass</code> at all</i>) , whereas this
  year was less fruitful with <strike>two</strike> one technique<strike>s</strike>:
</p>

  <ul>
    <li>
      <strong><strike>Bug #1</strike>: Disabling frontier</strong>: The kernel has to validate each
      user-provided pointer to check if it is coming from user or kernel
      space. This is done by <code>access_ok()</code> with a simple comparison of
      the address against a limit. <br />

      Sometimes, the kernel needs to use function normally designed to
      be called by userspace, and as such, theses functions checks the provenance
      of the pointer... which is embarrassing because the kernel only provides
      kernel pointers.<br />

      So the kernel goes evil and cheats by manipulating the boundary
      via <code>set_fs()</code> in order to make <code>access_ok()</code> always
      successful. At this moment and until the kernel undoes its boundary
      manipulation, there is no more protection against malicious pointers provided
      by userland.<br />

      <a href="http://blog.nelhage.com/">Nelson Elhage</a> found a brilliant way
      to get root: he triggers an assertion failure (via
      a <code>BUG()</code> or an <code>Oops</code>) that makes the kernel
      terminating the process with the <code>do_exit()</code> function. One Linux
      feature is to be able to notify the parent when one of its thread dies, the
      notification mechanism is as simple as writing a zero at a given
      address.<br />

      Normally of course, this address is checked to be inside the parent address
      space but if <code>do_exit()</code> was triggered in a context where the
      boundary was faked, that means that <code>access_ok(ptr)</code> will always
      return true. <br />

      This is what Nelson did by registering a pointer belonging to the kernel
      space for the notification and then triggered a NULL pointer dereference to 
      enter into a "temporary" context. Boom!
    </li>

    <li>
      <strong>Bug #2: Memory mapping</strong>: Tavis Ormandy discovered that when
      a process was instantiated,
      <a href="http://thread.gmane.org/gmane.linux.kernel/1074552">a carefully home made ELF binary could make the  VDSO page be mapped one page below <code>mmap_min_addr</code></a>. This is particularly interesting on
      <em>Red Hat Entreprise Linux</em>' kernel because it is configured
      with <code>mmap_min_addr</code> equals to 4096
      (<code>PAGE_SIZE</code>).<br />

      In other words, the VDSO page can be mapped on addresses 0 to 4096. In
      theory, that means the VDSO page could be used to "bounce" from a NULL
      pointer dereference.
    </li>
  </ul>
  

<p>
  Then in the end of 2010, this was the rediscovery of the impact of uninitialized
  variables, but in the kernel this time.
</p>

<h2>Uninitialized kernel variables</h2>

<p>
  A typical vulnerable code looks like the following:

<pre>
struct { short a; char b; int c; } s;

s.a = X;
s.b = Y;
s.c = Z;

copy_to_user(to, &amp;s, sizeof s);
</pre>

<p>
  The problem here is that we don't pay attention to the <i>padding</i> byte added
  by the compiler between <code>.b</code> and <code>.c</code>. This is needed in
  order to align structure members addresses on a CPU word.
</p>

<p>
  The direct consequence in the kernel case is that <code>copy_to_user()</code>
  obviously copies the structure as a whole and not "member by member", padding
  included.<br />
  The user process can thus get the value of this uninitialized byte, which can be
  totally useless, or as sensible as a key fragment.
</p>

<h3>The obvious fix?</h3>

<p>
  The fix seems relatively simple, by adding a preliminary <code>memset(&amp;s, '\0', sizeof s)</code>. But this not that trivial because C99 states that the compiler is free
  to optimize the following cases:
</p>

<ul>
  <li>
    Consider the <code>memset()</code> as superfluous as each structure
    member is assigned later, and thus removing it.
  </li>

  <li>
    Later, the padding byte can be overridden when <code>.b</code> is
    assigned. C99 does not protect this byte in any way so if the compiler can
    optimize its code by doing a <code>mov [ptr], eax</code> instead of <code>mov
    [ptr], ax</code>, he is free to do it.
  </li>
</ul>

<p>
  Furthermore, this <code>memset-ification</code> can be troublesome in fast paths
  like in the BPF filtering engine. netdev developers considered the
  <a href="http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.36.y.git;a=commit;h=2bd84dce08a6a782925f5e34c2e87ad957c57007">array initialization too expensive to be added</a> (even if this is as small as
  16*4 bytes).<br />
     
  Instead, they had to write a "BPF checker", validating the legitimacy of
  instructions accessing the array.
<p>

<h3>Impact of uninitialized variables</h3>

<p>
  This kind of bug <a href="https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf">was already demonstrated dangerous in userland</a> and this is even worse in kernel
  land! <br />

  However, motivating kernel developers to fix theses issues was not the easy part
  for some of them. For instance,
  the <a href="http://thread.gmane.org/gmane.linux.network/177506/focus=177549">netdev maintainer's scepticism</a> lead Dan Rosenberg to make
  a <a href="http://lists.grok.org.uk/pipermail/full-disclosure/2010-November/077321.html">blistering answer</a> with the publication of an exploit on <i>full-disclosure</i>. A few
  days later, <a href="http://permalink.gmane.org/gmane.comp.security.bugtraq/45315">he admitted having published this exploit because he was doubting about the impact of this particular vulnerability</a>.
</p>

<p>
  But this stays anecdotal (isn't it?) and kernel developers actively <a href="http://search.gmane.org/?query=uninitialized+memory&amp;author=&amp;group=gmane.linux.kernel&amp;sort=date&amp;DEFAULTOP=and&amp;xP=Zuniniti%09Zmemori&amp;xFILTERS=Glinux.kernel---A"> contributed to fix dozens occurrences of this kind of bug</a>.
</p>

<h3>Kernel stack expansion</h3>

<p>
  In 2005, <a href="http://cansecwest.com/core05/memory_vulns_delalleau.pdf">GaÃ«l Delalleau already discussed how interesting it was to make the stack and the heap collide in user land</a>. In November 2010, Nelson
  Elhage, <a href="http://ksplice.com/">Ksplice founder</a>, found a variant, but
  for the kernel this time.
</p>


<p>
  The memory allocated to the kernel is minimal, a kernel task can not have more
  than two physical pages for its local variables (its stack). But this is merely a
  convention given the fact there is no enforcement against abnormal expansion like a
  guard page. <br />

  Next to the task's stack (so after the "two pages") is the location of
  its <code>thread_info</code> structure, a critical element containing data and
  function's pointers... which would be really interesting to overwrite! <br />

  To happen, you have to <a href="http://cve.mitre.org/cgi-bin/cvename.cgi">find a task where you can control his stack usage</a>, like an array where its size is
  somehow user controlled. Eventually, this expansion will transcend the
  two-pages-limit and will offer you a way to overwrite some values
  in <code>thread_info</code> structure.

  A <a href="http://jon.oberheide.org/blog/2010/11/29/exploiting-stack-overflows-in-the-linux-kernel/">concrete exploitation of this flaw</a> overwrites one of the function's pointers to
  redirect to a shell code.
</p>


<h1>Ying: New protections</h1>


<h2>Bug fixes</h2>

<p>
  This year will not be the one of the change of Linus mentality towards security
  bugs but we catch up with it thanks to the efforts of security teams of various
  Linux distributions (Red hat, SuSe and Ubuntu mainly).
</p>

<p>
  It seems that they closely follow kernel mailing lists looking for sensible
  commits with a security impact. For each report, a CVE number is assigned, the
  kind of thing soooo useful for an admin because it permits some kind of
  traceability and to know (more or less) how pierced our servers are :)
  <br />

  Eugene Teo maintains an <a href="http://git.kernel.org/?p=linux/kernel/git/eugeneteo/linux-2.6-cve-tagged.git;a=summary">atypical git repository which tags every CVE</a>. This is particularly useful in audits
  for quickly identifying vulnerabilities available for a given version. This is
  somewhat the <i>whitehat equivalent</i>
  of <a href="http://xrayoptics.by.ru/database/localroot/lista_exploits_kernel.txt">kernel exploit lists</a> used by hackers.
</p>

<h2>Proactive security</h2>

<p>
  A lot of contributions were made to the kernel to improve its security
  proactively. Theses works try to make kernel exploitation more cumbersome,
  because frankly, we have to admit that the relative easiness to exploit a NULL
  pointer dereference is embarrassing :)
</p>

<p>
  For instance, to understand the interest of this kind of proactive measures,
  let's look back to Nelson's vulnerabilities: to be successful, 
  <a href="http://permalink.gmane.org/gmane.comp.security.full-disclosure/76457">Dan's exploit</a> had to combine three vulnerabilities to transform a denial of
  service into a privilege escalation.
</p>

<p>
  This <a href="http://en.wikipedia.org/wiki/Defense_in_depth_(computing)">defense in depth</a> shows us how expensive it becomes to exploit a given
  vulnerability. This is what we keep saying: there will always a vulnerability
  somewhere in our system, so our only option is to try to make its exploitation
  insane.
</p>

<p>
  But let's see what are theses proactive measures...
</p>

<h3>Permission hardening</h3>

<p>
  Brad Spengler, author of <a href="http://grsecurity.net/">grsecurity</a>, has
  long been vocal on the fact that too much information were leaked to user
  land. In consequence, grsec includes a lot of restrictions to prevent theses
  information leaks. But what are we talking about?
</p>

<p>
  <code>/proc</code>, <code>/sys</code> and <code>/debug</code> pseudo-filesystems
  contain files revealing kernel addresses, statistics, memory mapping, etc.<br />

  Except in debugging session, theses information are totally useless and
  meaningless. Nevertheless, most of theses files are world readable by
  default. This is godsend if you are an attacker: no need to bruteforce kernel
  addresses (and we know that bruteforcing this kind of thing in kernel land is
  never a good idea)!
<p>

<p>
  Dan Rosenberg and Kees Cook (of the Ubuntu security team) worked hard to merge
  theses restrictions into the official upstream tree:
</p>

<ul>
  <li>
    <a href="http://news.gmane.org/find-root.php?message_id=%3c1289273338.6287.128.camel%40dan%3e"><code><b>dmesg_restrict</b></code></a>:
    access to kernel log buffer (used by <code>dmesg(8)</code>) now
    require <code>CAP_SYS_ADMIN</code> capability.
  </li>

  <li>
    Removal of addresses in
    <a href="http://permalink.gmane.org/gmane.linux.kernel/1064008"><code>/proc/timer_list</code></a>,
    <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=59365d136d205cc20fe666ca7f89b1c5001b0d5a"><code>/proc/kallsyms</code></a>,
    etc. Upstream developers tried hard to not merge theses patches thinking it
    was useless (because addresses are also readable
    in <code>/boot/System.map</code>) and above all, it would greatly complicate
    the work of maintainers reading bug report. That is why 
    <a href="http://thread.gmane.org/gmane.linux.network/177739/focus=2076">netdev maintainer netdev clearly NAKed this kind of patches</a>. The zen and
    patience of Dan Rosenberg has to be highlighted here!<br />

    Alternatives were suggested by both parties:

    <br />
    <ul>
      <li>
        Since merely removing addresses from <code>/proc</code> files would break
        the ABI and thus a lot of scripts, it was proposed to replaced them by a
        dummy value (<code>0x000000</code>) if the reader was unprivileged.
      </li>

      <li>
        Changing access permissions to theses files, this "simple" change had a
        <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=33e0d57f5d2f079104611be9f3fccc27ef2c6b24"> nasty effect on an ancient version of klogd causing the machine to not boot anymore
        </a>. This lead to the revert of the patch unfortunately: Never break userspace!
      </li>

      <li>
        <code>XOR</code> displayed addresses with a secret value.
      </li>

      <li>
        Etc.
      </li>
    </ul>
  </li>
</ul>

<p>
  The solution "retained" (there is never a formal "Yes this is it", you have to
  write the code and then this is discussed...) is the first one: replacing
  addresses by arbitrary values if reader not privileged.<br />

  However, in order to prevent code duplication, the special 
  <a href="http://news.gmane.org/find-root.php?message_id=%3c1292692835.10804.67.camel%40dan%3e"> <i>format specifier</i> <code>%pK</code> </a> 
  was added to <code>printk()</code>. Depending on the <code>kptr_restrict</code>
  sysctl, this specifier will restrict access to pointers.
</p>

<p>
  For the occasion,
  <a href="http://permalink.gmane.org/gmane.linux.kernel.lsm/12185"> the new capability <code>CAP_SYSLOG</code> </a>
  was created for this purpose.
</p>

<p>
  A lot of work is still needed however, for example, thanks 
  <a href="http://codemonkey.org.uk/2010/12/15/system-call-fuzzing-continued/"> to his new fuzzer</a>, Dave Jones <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4347"> discovered that the loader of ACPI table was word-writable: </a>
  anybody could load a new ACPI table if <code>debugfs</code> was mounted, oops :)
</p>

<h3>Marking kernel memory read only</h3>

<p>
  Actually, the Linux kernel does not use all possibilities offered by the
  processor for its own memory management: read-only segments are not really
  marked as so internally. Things could be improved like what is now done in
  user space: data shall not be executable, code shall be read-only, etc.
</p>

<p>
  This is still a work in progress, but developers try
  to <a href="http://thread.gmane.org/gmane.linux.kernel/1058823">remediate theses issues</a>. To be successful, a few actions are needed:
</p>

<ul>
  <li>
    <a href="http://git.kernel.org/?p=linux/kernel/git/x86/linux-2.6-tip.git;a=commitdiff;h=65187d24fa3ef60f691f847c792e8eaca7e19251"> Really use hardware permission for the <code>.ro.data</code> segment </a>.
    Because for the moment, permissions for this segment are purely virtual
    despite the ".ro" in its name.
  </li>

  <li>
    Function pointers never modified shall be marked as <code>const</code>-ant
    whenever possible. Indeed, one of the simplest method to exploit a kernel
    vulnerability is to overwrite a function pointer to jump in attacker
    area. <br />

    Once a variable is marked <code>const</code>, it is moved into the
    previously seen <code>.ro.data</code> (you can guess that this move is only
    useful if the zone is really read only in hardware).

    Off course, it will not be possible to <code>const</code>-ify every function
    pointers, there will still be room for an attacker but this is not a reason to
    do nothing...
  </li>

  <li>
    Disabling some entry points leading to <code>set_kernel_text_rw()</code> (the
    "kernel" equivalent of <code>mprotect()</code>) in order to not let attacker to
    change permissions after all.
  </li>
</ul>

<p>
  A priori, developers do not seem opposed to this patch and they would be even
  happy to merge it in order to
  <a href="http://article.gmane.org/gmane.linux.kernel/1058954"> optimize virtualized guests</a>.
</p>

<h3>Disabling module auto-loading</h3>

<p>
  Most of the vulnerabilities target code paths barely used. This could, by the
  way, be the reason why bugs are still found.
</p>

<p>
  Linux distributions don't have other option than compiling every features and
  drivers to have a unique universal kernel. To not bloat the memory, this is done
  via modules with a way to load them on demand.
</p>

<p>
  This auto-loading feature is particularly interesting for attackers: they just
  have to request an X.25 socket to have its associated module loaded, ready to be
  exploited.
</p>

<p>
  Dan Rosenberg (again!) 
  <a href="http://article.gmane.org/gmane.linux.kernel/1058922"> proposed to automatically load modules only if the triggering process is privileged</a>.
  Even if this restriction is already inside grsecurity patches, this "feature"
  was considered too dangerous for distributions and was NAKed to prevent any
  breakage :-/
</p>

<h3><code>UDEREF</code> support for AMD64 (finally)</h3>

<p>
  PaX developers have always been clear: AMD64 Linux systems will never been as
  secure as their i386 cousin. This statement is due to the lack of the
  segmentation.
</p>

<p>
  However, they did their best
  to <a href="http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html">implement <code>UDEREF</code></a>
  anyway.
</p>

<p>
  As a reminder, <code>UDEREF</code> prevents the kernel to use memory owned by
  user land without stating it explicitly. This features offers protection
  against <em>NULL pointer dereferences</em> bugs.
</p>

<p>
  On i386, this is easily done by using segmentation logic. But on AMD64, this
  stays a (dirty) hack by moving the user space zone at another place and change
  its permissions.
</p>

<p>
  The problem is that we just shift the issue: now, instead of deferencing a null
  pointer, attacker now has to influence the kernel to dereference another
  address, but as pageexec said, if we are at this point, this should the last of
  our concern :)

  <br />

  As if this wasn't enough, this hack "wastes" 5 bits of addressing (leaving 42
  bits for the process) and some bits of d'<abbr title="Address
  Space Layout Randomization">ASLR</abbr> by the way...<br />

  The icing on the cake is that the performance are impacted for each transition
  user-to-kernel and kernel-to-user because of the TLB flush.
</p>

<h2>Network security?</h2>

<p>
  Network security is not really "sexy" enough to receive the same level of
  contributions to the Linux kernel, maybe because researchers prefers to work on
  offensive things.<br />

  Besides the <a href="http://lwn.net/Articles/324989/">Netfilter rewrite (called nftable) started last year</a>, not so many things happened. One of the few
  things remarkable was the implementation
  of <a href="http://kernelnewbies.org/Linux_2_6_33#head-2c3c3a8cb87d5b7a6f1182e418abf071cda22c8c">TCP Cookie Transactions</a> et improvements to "old" syncookies.
</p>

<p>
  When a system is overloaded, TCP syncookies are used to not store states until
  the connection is really opened. This "old-school" protection was designed
  to evade from SYN flood attacks. Nowadays, this is merely pointless since
  today's DoS saturate the network bandwidth instead of the kernel memory.<br />

  Anyway, this is not a reason to do nothing :)
</p>

<p>
  Previously, SYNcookies were considered as "has to be used in last resort"
  because TCP options carried by the first SYN packet were lost since the kernel
  was not saving it (congestion bit, <i>window scaling</i> or <i>selective
  acknowledgement</i>).
</p>

<p>
  This is not true
  anymore: <a href="http://git.kernel.org/?s=4dfc2817025965a2fc78a18c50f540736a6b5c24">the kernel now codes theses information</a> into the 9 lower bits of the TCP
  Timestamp's SYN-ACK option when replying. <br />

  This means that syncookie is not harmful anymore for performances and can be used
  safely, despite what says
  the <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/tcp.7.html">tcp(7)</a>
  manpage (a bug was submitted to update the description).
</p>

<h1>Kernel confessions</h1>

<p>
  While reading lists, I came across some interesting confessions:
</p>

<a href="http://permalink.gmane.org/gmane.linux.kernel.lsm/12196">The capabilities drama</a>&nbsp;:
<blockquote>
Quite frankly, the Linux capability system is largely a mess, with big
bundled capacities that don't make much sense and are hideously
inconvenient with the capability system used in user space (groups).
<br />
-hpa
</blockquote>

<a href="http://permalink.gmane.org/gmane.linux.kernel/1068774">Too many patches to review for the -stable branch</a>&nbsp;:<br />
<blockquote>
> > I realise it wasn't ready for stable as Linus only pulled it in <br />
> > 2.6.37-rc3, but surely that means this neither of the changes <br />
> > should have gone into 2.6.32.26.<br />
> Why didn't you respond to the review??<br />
<br />
I don't actually read those review emails, there are too many of them.
</blockquote>

<h1>Conclusion </h1>

<p>
  A lot of good things happened in the Linux kernel last year thanks to the people
  cited in this post. Moreover, it is interesting to see that most of theses
  features have been written by security researchers and not "upstream kernel
  developer" (except Ingo Molnar who proved a lot of good will each time).
  <br />

  This may be the explanation why each patch merged was the fruit of never-ending
  threads (we can applause
  <a href="http://thread.gmane.org/gmane.linux.kernel/1015999/focus=1018279">their patience</a>)...

  <br />

  This is only now that I start understanding how much Brad Spengler was right
  when he <a href="http://grsecurity.net/lsm.php">declared war against LSM</a>. Do
  "Security" subsystem maintainers should leave their ivory tower and start
  understanding the real life of a syadmin? The kind of guy who don't have time to
  update every servers to the latest git version, nor to write SELinux which, by
  the way, would be useless once a kernel vulnerability is found.

  <br />

  Anyway, this is only the opinion of a guy involved in
  the <a href="http://article.gmane.org/gmane.linux.kernel/706950">security circus</a>...
</p>

<p>
  However, we can still be happy to see theses changes finally merged. And with some
  luck, we can hope that someday, <code>mmap_min_addr</code> will not be
  bypassable... And that proactive features will require researchers to
  combine multiple vulnerabilities to exploit one flaw.<br />

  I don't say that there will be no more bugs, perish the throught, but I hope
  that the exploitation cost will be so high that only a tiny fraction of attacker
  will be able to do it. <br />

  At this point, security researchers will have to dive into "logic bugs", like
  <a href="http://seclists.org/fulldisclosure/2010/Oct/257">Taviso's vulnerabilities <code>LD_PRELOAD</code>/<code>LD_AUDIT</code></a> which were
  bypassing most of available hardening protections.
</p></div>
