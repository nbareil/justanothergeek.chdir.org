---
categories:
- sandbox
- linux
- syscall
- seccomp
date: "2010-03-04T14:10:00Z"
title: SECCOMP as a Sandboxing solution ?
---

<div class='post'>
<h3>Sandboxing technology? </h3>

<p>
SECCOMP is a Linux feature introduced in 2.6.23 (2005) by
<a href="http://www.cpushare.com/blog/andrea/">Andrea Arcangeli</a>, initially designed for grid computing
applications. The idea was to sell CPU times to the public by
running untrusted binaries.
</p>
<p>
When a process goes into SECCOMP mode, it can only do 4 syscalls:
<code>read</code>, <code>write</code>, <code>_exit</code> and <code>sigreturn</code>. The kernel will enforce this
limitation by killing (by a SIGKILL signal) the process if an
unauthorized system call is made.
</p>
<p>
The security warranty here is pretty strong: the only way to evade
the protection is to use file descriptors already opened or access
to shared memory.
</p>
<p>
SECCOMP is the perfect solution for a sandbox because the kernel
attack surface is really small! For the record, in the whole kernel
security history, no vulnerability was ever found in theses
syscalls.
</p>
<p>
The downside of this feature is its limitation! Once in SECCOMP
mode, it is impossible to do anything except some
arithmetics. Another SECCOMP problem is that the action of entering
in SECCOMP mode is voluntary: the program needs to issue itself a
<code>prctl()</code> call with appropriate arguments: that means the
application needs to be developed specifically.
</p>
<p>
The purpose of a sandbox is to run untrusted binaries without
requiring sources modifications. Currently, there are two
main problems:
</p>
<ul>
<li>
Enter in SECCOMP mode

</li>
<li>
Prevent the untrusted process from issuing system call

</li>
</ul>

<p>Both problems need to be solved without requiring a
recompilation. How to do it despite this constraint?
</p>
<h3> Entering in SECCOMP mode </h3>


<p>
Basically, we need to inject a call to <code>prctl()</code> into a given
process. The best known method is to write directly into the memory
of the process by using the <code>ptrace()</code> interface.
</p>
<p>
Beside the evident problems of portability and the inherent
difficulties of injecting instructions in a process, this solution
was not investigated because of its hackish nature.
</p>
<p>
Instead, let's take a look at a simple binary:
</p>



<pre class="src src-txt">$ objdump -f a.out
a.out:     file format elf32-i386
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080482e0
</pre>



<p>
The entry point of the binary, <code>0x080482e0</code>, is the <code>_start</code> routine
provided by the compiler and shown here:
</p>



<pre class="src src-asm"><span style="color: #0000ff;">080482e0</span> &lt;_start&gt;:
 <span style="color: #a020f0;">80482e0</span>:       31 ed                   xor    ebp,ebp
 <span style="color: #a020f0;">80482e2</span>:       5e                      pop    esi
 <span style="color: #a020f0;">80482e3</span>:       89 e1                   mov    ecx,esp
 <span style="color: #a020f0;">80482e5</span>:       83 e4 f0                and    esp,0xfffffff0
 <span style="color: #a020f0;">80482e8</span>:       50                      push   eax
 <span style="color: #a020f0;">80482e9</span>:       54                      push   esp
 <span style="color: #a020f0;">80482ea</span>:       52                      push   edx
 <span style="color: #a020f0;">80482eb</span>:       68 b0 83 04 08          push   0x80483b0
 <span style="color: #a020f0;">80482f0</span>:       68 c0 83 04 08          push   0x80483c0
 <span style="color: #a020f0;">80482f5</span>:       51                      push   ecx
 <span style="color: #a020f0;">80482f6</span>:       56                      push   esi
 <span style="color: #a020f0;">80482f7</span>:       68 94 83 04 08          push   0x8048394
 <span style="color: #a020f0;">80482fc</span>:       e8 c7 ff ff ff          call   80482c8 &lt;<a href="mailto:__libc_start_main&#64;plt">__libc_start_main&#64;plt</a>&gt;
</pre>



<p>
It initializes the stack and then calls the "init function" of the GNU
libc which will eventually execute the <code>main()</code> function. At this
point, the program is effectively ran.
</p>
<p>
The interesting property of this routine is how the libc function is
called: by using the Procedure Linkage Table (PLT). In a few words,
that means the linker will have to resolve the symbol.
</p>

<p>
Thanks to the <code>LD_PRELOAD</code> feature, it's possible to overload
ELF symbols. This is how we are issuing the <code>prctl()</code> call: by overriding
the <code>__libc_start_main</code> function and calling it on our own to be
totally transparent, here is how it's done:
</p>



<pre><span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">int</span> (*<span style="color: #228b22;">main_t</span>)(<span style="color: #228b22;">int</span>, <span style="color: #228b22;">char</span> **, <span style="color: #228b22;">char</span> **);
<span style="color: #228b22;">main_t</span> <span style="color: #a0522d;">realmain</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">__libc_start_main</span>(<span style="color: #228b22;">main_t</span> <span style="color: #a0522d;">main</span>,
                      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>,
                      <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">__unbounded</span> *__unbounded ubp_av,
                      ElfW(<span style="color: #228b22;">auxv_t</span>) *__unbounded auxvec,
                      __typeof (main) init,
                      <span style="color: #228b22;">void</span> (*<span style="color: #a0522d;">fini</span>) (<span style="color: #228b22;">void</span>),
                      <span style="color: #228b22;">void</span> (*<span style="color: #a0522d;">rtld_fini</span>) (<span style="color: #228b22;">void</span>), <span style="color: #228b22;">void</span> *<span style="color: #a0522d;">__unbounded</span>
                      stack_end)
{
        <span style="color: #228b22;">void</span> *<span style="color: #a0522d;">libc</span>;
        <span style="color: #228b22;">int</span> (*<span style="color: #a0522d;">libc_start_main</span>)(<span style="color: #228b22;">main_t</span> <span style="color: #a0522d;">main</span>,
                               <span style="color: #228b22;">int</span>,
                               <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">__unbounded</span> *__unbounded,
                               ElfW(<span style="color: #228b22;">auxv_t</span>) *,
                               <span style="color: #228b22;">__typeof</span> (<span style="color: #a0522d;">main</span>),
                               <span style="color: #228b22;">void</span> (*<span style="color: #a0522d;">fini</span>) (<span style="color: #228b22;">void</span>),
                               <span style="color: #228b22;">void</span> (*<span style="color: #a0522d;">rtld_fini</span>) (<span style="color: #228b22;">void</span>),
                               <span style="color: #228b22;">void</span> *<span style="color: #a0522d;">__unbounded</span> stack_end);

        libc = dlopen(<span style="color: #8b2252;">"libc.so.6"</span>, RTLD_LOCAL  | RTLD_LAZY);
        <span style="color: #a020f0;">if</span> (!libc)
                ERROR(<span style="color: #8b2252;">"  dlopen() failed: %s\n"</span>, dlerror());
        libc_start_main = dlsym(libc, <span style="color: #8b2252;">"__libc_start_main"</span>);
        <span style="color: #a020f0;">if</span> (!libc_start_main)
                ERROR(<span style="color: #8b2252;">"     Failed: %s\n"</span>, dlerror());

        realmain = main;
        <span style="color: #228b22;">void</span> (*<span style="color: #a0522d;">__malloc_initialize_hook</span>) (<span style="color: #228b22;">void</span>) = my_malloc_init;
        <span style="color: #a020f0;">return</span> (*libc_start_main)(wrap_main, argc, ubp_av, auxvec,
        init, fini, rtld_fini, stack_end);
}
</pre>



<p>
In a nutshell:
</p>
<ol>
<li>
The first parameter of the function is the address of the <code>main</code>
</li>
<li>
We open the libc library object
</li>
<li>
We find the location of the original <code>__libc_start_main</code>
</li>
<li>
We save the original <code>main</code> function into a global variable
</li>
<li>
We call the original <code>__libc_start_main</code> by replacing the
original <code>main</code> by our own (<code>wrap_main</code>) shown here:


</li>
</ol>


<pre><span style="color: #228b22;">int</span> <span style="color: #0000ff;">wrap_main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span> **<span style="color: #a0522d;">argv</span>, <span style="color: #228b22;">char</span> **<span style="color: #a0522d;">environ</span>)
{
        <span style="color: #a020f0;">if</span> (prctl(PR_SET_SECCOMP, 1, 0, 0) == -1) {
                perror(<span style="color: #8b2252;">"prctl(PR_SET_SECCOMP) failed"</span>);
                printf(<span style="color: #8b2252;">"Maybe you don't have the CONFIG_SECCOMP support built into your kernel?\n"</span>);
                exit(1);
        }

        (*realmain)(argc, argv, environ);
}
</pre>




<p>
At this point, the original <code>main()</code> is called and the program is
executed under SECCOMP. The drawback of this method is its
incompatibility with statically linked binary. In this case, the
<code>_start</code> routine calls directly <code>__libc_start_main</code> function without
using the PLT.
</p>

<p>
The big vulnerability here is the case of a malicious binary with a <code>_start</code> routine not calling <code>__libc_start_main</code>, in that case, the <code>prctl()</code> would not be done and the program would run without sandboxing. This issue was ignored for the moment but it will require some thought...
</p>

<p>
There is still the option of modifying the memory with some
<code>ptrace()</code> calls or
<a href="http://c-skills.blogspot.com/2010/02/runtime-hot-patching-processes-wo.html">rewriting some memory mapping thanks to the method of Sebastian Krahmer presented in lasso</a>.
</p>

<h3> Interception of syscalls </h3>


<p>
Now that the application is running under SECCOMP, it's not possible
anymore to do a syscall (except <code>read</code>, <code>write</code>, <code>_exit</code> and
<code>sigreturn</code>). Because we made the assumption that the sandboxed
program was not designed to run SECCOMP, we have to prevent it from
issuing such forbidden call.
</p>
<p>
Thus, we need to intercept the syscall before the kernel, process it
if possible and emulate the kernel behavior. The interception of
syscalls is usually done, again, with the <code>ptrace()</code> interface, the
main drawback of this method is the lack of debugging mean: because
all debuggers use <code>ptrace</code> and a process can only be traced once,
that means that each bug would be a nightmare.
</p>
<p>
Furthermore, the <code>ptrace</code> interface is known to be crippled and a
lot of security bugs have been found, fortunately, this was from the
tracer side, but there was some advisories where the tracee could
harm the tracer process.
</p>
<p>
Another solution was investigated based on the analysis of the
syscall handling in the Libc. We saw in my <a href="http://justanothergeek.chdir.org/2010/02/how-system-calls-work-on-recent-linux.html">previous post "How system calls work on Linux?"</a>
that the GNU Libc was making syscalls by doing a <code>call *%gs:0x10</code> (where 0x10 is variable).
</p>

<h4> Hijacking VDSO </h4>

<p>
In order to intercept (legit) sycalls, we need to intercept the
previous <code>call</code> instruction. This is easy, we have to overwrite the
pointer stored at the address <code>%gs:0x10</code> and redirect the process to
our own function.
</p>
<p>
This what we do immediatly after turning on SECCOMP:
</p>



<pre><span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">hijack_vdso_gate</span>(<span style="color: #228b22;">void</span>) {
        <span style="color: #a020f0;">asm</span>(<span style="color: #8b2252;">"mov %%gs:0x10, %%ebx\n"</span>
            <span style="color: #8b2252;">"mov %%ebx, %0\n"</span>

            <span style="color: #8b2252;">"mov %1, %%ebx\n"</span>
            <span style="color: #8b2252;">"mov %%ebx, %%gs:0x10\n"</span>

            : <span style="color: #8b2252;">"=m"</span> (real_handler)
            : <span style="color: #8b2252;">"r"</span> (handler)
            : <span style="color: #8b2252;">"ebx"</span>);
} <span style="color: #a020f0;">__attribute__</span>((always_inline));
</pre>



<p>
From now on, every syscalls are trapped by our handler, even the one
which are "allowed" by SECCOMP.
</p>

<h4> Demultiplexing syscalls </h4>


<p>
The purpose of the handler is to look at the syscall requested, see
if we need to honor it ourself (because it's a forbidden syscall) or
run the original VDSO's function.
</p>
<p>
Our handler needs to be carefully written in order to not mess up
with the registers: our function <b>must not</b> modify any
register. That is the reason why it was written in assembly:
</p>



<pre><span style="color: #228b22;">void</span> <span style="color: #0000ff;">handler</span>(<span style="color: #228b22;">void</span>) {
        <span style="color: #b22222;">/* </span><span style="color: #b22222;">syscall_proxy() is the "forbidden syscalls" handler </span><span style="color: #b22222;">*/</span>
        <span style="color: #228b22;">void</span> (*<span style="color: #a0522d;">syscall_proxy_addr</span>)(<span style="color: #228b22;">void</span>) = syscall_proxy;

        <span style="color: #a020f0;">asm</span>(<span style="color: #8b2252;">"cmpl $4, %%eax\n"</span>
            <span style="color: #8b2252;">"je do_syscall\n"</span>

            <span style="color: #8b2252;">"cmpl $3, %%eax\n"</span>
            <span style="color: #8b2252;">"je do_syscall\n"</span>

            <span style="color: #8b2252;">"cmpl $0xfc, %%eax\n"</span>
            <span style="color: #8b2252;">"jne wrapper\n"</span>

            <span style="color: #8b2252;">"movl $1, %%eax\n"</span>
            <span style="color: #8b2252;">"jmp do_syscall\n"</span>

            <span style="color: #8b2252;">"wrapper:\n"</span>
            <span style="color: #8b2252;">"                   call *%0\n"</span>
            <span style="color: #8b2252;">"                   jmp out\n"</span>

            <span style="color: #8b2252;">"do_syscall:\n"</span>
            <span style="color: #8b2252;">"                   call *%1\n"</span>
            <span style="color: #8b2252;">"out:               nop\n"</span>

            : <span style="color: #b22222;">/* </span><span style="color: #b22222;">output </span><span style="color: #b22222;">*/</span>
            : <span style="color: #8b2252;">"m"</span> (syscall_proxy_addr),
              <span style="color: #8b2252;">"m"</span> (real_handler)); <span style="color: #b22222;">/* </span><span style="color: #b22222;">real_handler is the original
                                    * VDSO function, performing 
                                    * effectively the syscall 
                                    </span><span style="color: #b22222;">*/</span>
}
</pre>



<p>
Each time the libc makes a syscall, we either perform the action
directly or we call our "syscall proxy". More on that later...
</p></div>


