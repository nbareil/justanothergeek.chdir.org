---
date: "2012-01-24T16:16:00Z"
title: Linux security in 2011, or my LKML’s yearly digest
---

<div class='post'>
<h3>
Linux security in 2011, or LKML’s yearly digest</h3>

<p>
  <b>Disclaimer</b>: I have nothing to do with the following, all credits go to their respective authors. 
  I'm just publishing my 2011's bookmarks about Linux kernel security with a one line summary based 
  on my (possibly wrong) understanding<br />
  Do not hesitate to correct me (gently if possible :)) in comments or mail.
</p>

<ul>
<li><a href="http://forums.grsecurity.net/viewtopic.php?f=7&amp;t=2522">False boundaries of (certain) capabilities</a>: Brad Spengler describes 19
  capabilities (of 35) which can be used to regain full
  privileges. Coincidentally, <a href="http://thread.gmane.org/gmane.linux.kernel/1105168/focus=1107204">Vasily Kulikov discovered a “funny” behavior of CAP_NET_ADMIN</a> which
  permit to load any modules available in /lib/modules/ instead of
  limiting to network related modules only, AFAIK, this vulnerability
  was closed but the fix got reverted some weeks later because of some
  userspace
  breakages.
  </li>

<li>
    <a href="http://lwn.net/Articles/461811/">PaX team introduced a new range of stuff</a> using
      the <a href="http://lwn.net/Articles/457543/">new GCC plugin infrastructure</a>. At compile-time, pro-active code is
      automatically added to potentially dangerous paths:

    <ul>
<li><code>constify_plugin.c</code> enforces read-onlintroduces
      new constraints (<code>__do_const</code>
      and <code>__no_const</code>) enforcing read-only permissions at
      compilation-time and run-time. PaX then makes usage of theses
      new constraints by patching most of the “ops structures”. The
      plugin also automatically protects structures where all members
      are function pointers, this patching on-the-fly is required
      because patching directly the source kernel would never be
      integrated upstream.
      </li>
<li><code>stackleak_plugin.c</code> adds instrumentation code
      before <code>alloca()</code> calls. This code checks that
      stack-frame size does not overlap with kernel task size. It
      circumvents techniques described
      in <a href="http://cansecwest.com/core05/memory_vulns_delalleau.pdf">"Large memory management vulnerabilities" by Gaël Delalleau</a> (2005)
      and <a href="http://jon.oberheide.org/files/infiltrate12-thestackisback.pdf">"The stack is back" by Jon Oberheide</a> (2012).</li>
<li>GCC 4.6
      introduced <a href="http://gcc.gnu.org/onlinedocs/gccint/Named-Address-Spaces.html">named address spaces</a>. It was initially specified for embedded
      processors but PaX team uses this feature to represent user and
      kernel space. <code>checker_plugin.c</code> thus
      introduces <code>__user</code>, <code>__kernel</code>
      and <code>__iomem</code> namespaces to spot non-legit flows between
      address spaces.</li>
<li><code>kallocstat_plugin.c</code> produces statistics about
      the size given in parameter to various memory allocation
      functions</li>
<li><code>kernexec_plugin.c</code> enforces non-executable pages
      like the <code>KERNEXEC</code> PaX feature, but without huge
      performance impact on AMD64.</li>
</ul>
</li>
<li><a href="http://thread.gmane.org/gmane.comp.compilers.clang.devel/13365">pagexec also managed to compile Linux Kernel with clang</a> by patching both
  Linux and clang. Now that gcc integrated plugins, it is less
  interesting &nbsp;but llvm was the solely compiler with easy access
  to its internal structure, allowing external applications to perform
  static analysis...</li>
<li>A <a href="http://article.gmane.org/gmane.linux.kernel.cryptoapi/5304">user space interface to kernel Crypto-API was submitted to kernel developers</a>, an interesting use-case was to offer a way to deport
  key material between processes. Imagine process A in possession of
  private keys and another one, B, actually performing encryption
  / decryption stuff part. The idea was to initialize a “crypto
  socket” in A and pass this file descriptor to B (via a classic
  ancillary message).
</li>
<li>Pseudo-files in <code>/proc/&lt;pid&gt;/</code> have a different
  security model than “normal” files because of its ephemeral nature:
  checks need to happen during each system call and not
  at <code>open()</code> time because permissions can change at anytime. <a href="http://www.halfdog.net/Security/2011/SuidBinariesAndProcInterface/">Halfdog discovered</a>
  (and <a href="http://thread.gmane.org/gmane.linux.kernel/1097206">Kees Cook reported it to LKML</a>) that not all files were protected
  accordingly. If a program opens <code>/proc/self/auxv</code> and
  keeps this file descriptor opened. Then, even after
  a <code>execve()</code> of a setuid binary, the file descriptor
  would still be available, leaking information! Fixing this
  vulnerability has been a long road and a pretty solution came up
  with the introduction of <code>revoke()</code>, a new syscall
  invalidating file descriptors. Unfortunately, the thread didn’t
  survive and ideas were lost... (by the way, it is funny that this
  kind of problem resuscitated in CVE-2012-0056 lately...)</li>
<li>As one goes along, <code>execve()</code> became almost magical, it had to
  support Set-User-Id, capabilities, and file capabilities. Each
  feature added complexity and different legacy behaviors to maintain. Instead of
  dropping these POSIX features, OpenWall 3.0 took a different
  approach by removing Suid binaries from its base install, thus
  preventing execve’s voodoo. This change is just a line in Owl’s
  changelog but is in fact a major achievement: it required them to
  re-architecture important softwares like crontab
  or <a href="http://www.openwall.com/tcb/">user management tools</a>.<br /> <code>/bin/ping</code> is setuid-root because it opens a
  raw socket and injects its packet on the wire
  directly. <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=c319b4d76b9e583a5d88d6bf190e079c4e43213d">A new socket type, <code>PROT_ICMP</code>, was developed by Openwall team,</a> it makes possible to send ICMP Echo messages without
  special privileges (caller’s GID has to be included in a range
  stored in a sysctl key). It is interesting to note that only replies
  (based on ICMP identifier field) are sent to userspace, not the
  whole ICMP traffic like in Mac OS X.</li>
<li><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=6e5714eaf77d79ae1c8b47e3e040ff5411b717ec">TCP Initial Sequence number is now a 32-bits random number using MD5</a>. ISN was previously the concatenation of 24 random bits (MD4 of TCP end points with a secret rekeyed every 5 minutes) and an 8
  bits counter (number of times secret key was regenerated)</li>
<li>Vasilily tried to push
  upstream <a href="http://permalink.gmane.org/gmane.linux.kernel.cross-arch/10430">additional checks for <code>copy_{to,from}_user()</code></a> (by checking if requested size fits boundaries fixed at compile time), this patch
  was a cut down version of <code>PAX_USERCOPY</code> but was NACKed
  by Linus asking him for more “balance and sanity”. However, he didn’t
  reject the idea itself, saying that a cleaner version might be
  accepted...</li>
</ul></div>
