---
categories:
- glibc
- syscall
- kernel
date: "2010-02-20T22:11:00Z"
title: How system calls work on recent Linux x86 glibc
---

<div class='post'>
This post explains how system calls are implemented on recent 
Linux system. It covers only the x86_32 platform, on a recent Linux kernel 
and GNU Libc (where recent means "released after 2005").

<br />
<h3> Processor facility for making syscall </h3>
On x86, userspace processes run in ring 3, while the kernel is in
ring 0. Only the kernel can do the interface between the resources
and the processes.
<br />
A resource can be an access to a hardware device, a kernel object or
any kind of IPC. In other words, each time it is needed to do such
action, the userspace application has to make a request to the
kernel; this is what we call a system call (syscall), basically,
this is the transition from a ring to another one.
<br />
Historically, on Linux and x86, the best known method for performing
a syscall is to generate an interruption (the classic <code>int $0x80</code>
instruction) which is trapped by the kernel and then processed.
<br />
It was the most efficient way until the Pentium 4 where it
became the slowest mechanism available. The best method became the
<code>sysenter/sysexit</code> instructions on <code>x86_32</code> which is usable the same
way than with the interrupt. For instance, here is a simple call to
<code>_exit(42)</code>:
<br />
<pre><span style="color: blue;">mov</span> <span style="color: #a020f0;">$1</span>, <span style="color: sienna;">%eax</span>   <span style="color: firebrick;">;; </span><span style="color: firebrick;">__NR_exit = 1
</span><span style="color: blue;">mov</span> <span style="color: #a020f0;">$42</span>, <span style="color: sienna;">%ebx</span>  <span style="color: firebrick;">;; </span><span style="color: firebrick;">status = 42
</span><span style="color: blue;">sysenter</span>       <span style="color: firebrick;">;; </span><span style="color: firebrick;">perform the syscall!
</span></pre>
On AMD64, a similar mechanism exists: <code>syscall=/=sysret</code> which is,
by the way, known to be a better interface and more performant than
its Intel equivalent. Anyway.
<br />
Usually, except shellcodes, syscalls are generated by the libc and,
depending on the processor, using one solution or another can have
strong impact on performances : if the libc keeps using <code>int $0x80</code>
even on modern CPU, the performances will be bad.
<br />
The problem is that, usually, Linux distributions provide only one
compiled version of the libc: it has to run equally well on all CPU
versions (486, 586 or 686). Thus, there was a need for an
abstraction layer called by the libc which would choose the best
mechanism at runtime.
<br />
This is done by the kernel: it is compiled with all syscalls
mechanisms and selects the best one at boot time. Once a method is
chosen, it exposes a function to userspace calling directly the
selected methods. This way of exposing page is called a Virtual
Dynamical Shared Object, or VDSO.
<br />
From the other side, in the libc, making a system call is just a
matter of calling a VDSO's function, without knowing if a historical
interrupt will be done or a <code>sysenter</code>.
<br />
If we rewrite our previous snippet and make it use the vdso:
<br />
<pre><span style="color: blue;">movl</span> <span style="color: #a020f0;">$1</span>, <span style="color: sienna;">%eax</span>   <span style="color: firebrick;">;; </span><span style="color: firebrick;">__NR_exit = 1
</span><span style="color: blue;">movl</span> <span style="color: #a020f0;">$42</span>, <span style="color: sienna;">%ebx</span>   <span style="color: firebrick;">;; </span><span style="color: firebrick;">status   = 42
</span><span style="color: blue;">call</span> *<span style="color: sienna;">%gs</span>:0x10  <span style="color: firebrick;">;; </span><span style="color: firebrick;">Here, the offset (0x10) is platform-dependent
</span>                <span style="color: firebrick;">;; </span><span style="color: firebrick;">The memory page %gs:0x10 is located in the VDSO
</span></pre>
<h3>

Virtual Dynamic Shared Object </h3>
A Virtual Dynamic Shared Object (VDSO) is a page maintained by the
kernel and exposed to userspace by mapping this page into its
address space. For instance:
<br />
<pre>$ cat /proc/self/maps
08048000-08051000 r-xp 00000000 fd:01 14450888   /bin/cat
08051000-08052000 rw-p 00009000 fd:01 14450888   /bin/cat
083d7000-083f8000 rw-p 00000000 00:00 0          [heap]
b7475000-b7633000 r--p 00000000 fd:01 592041     /usr/lib/locale/locale-archive
b7633000-b7634000 rw-p 00000000 00:00 0 
b7634000-b7775000 r-xp 00000000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
b7775000-b7777000 r--p 00141000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
b7777000-b7778000 rw-p 00143000 fd:01 5769153    /lib/i686/cmov/libc-2.10.2.so
b7778000-b777b000 rw-p 00000000 00:00 0 
b7794000-b7796000 rw-p 00000000 00:00 0 
b7796000-b7797000 r-xp 00000000 00:00 0          [vdso]
b7797000-b77b3000 r-xp 00000000 fd:01 2818106    /lib/ld-2.10.2.so
b77b3000-b77b4000 r--p 0001b000 fd:01 2818106    /lib/ld-2.10.2.so
b77b4000-b77b5000 rw-p 0001c000 fd:01 2818106    /lib/ld-2.10.2.so
bfafd000-bfb12000 rw-p 00000000 00:00 0          [stack]
</pre>
Here, the VDSO is one page long (4096 bytes). It contains the
syscall abstraction interface, but also some shared variables (low
level information like rdtsc counter, real-time timer, stack canary,
etc.)
<br />
The selection of the right syscall method is done by the Linux
kernel in <a href="http://lxr.linux.no/#linux+v2.6.32/arch/x86/vdso/vdso32-setup.c"><code>arch/x86/vdso/vdso32-setup.c</code></a> in the <code>sysenter_setup</code>
function (which is called very early at kernel initialization by
<code>identify_boot_cpu()</code>).
<br />
<pre><span style="color: forestgreen;">int</span> <span style="color: blue;">__init</span> sysenter_setup(<span style="color: forestgreen;">void</span>)
{
    <span style="color: forestgreen;">void</span> *<span style="color: sienna;">syscall_page</span> = (<span style="color: forestgreen;">void</span> *)get_zeroed_page(GFP_ATOMIC);
    <span style="color: #a020f0;">const</span> <span style="color: forestgreen;">void</span> *<span style="color: sienna;">vsyscall</span>;
    <span style="color: forestgreen;">size_t</span> <span style="color: sienna;">vsyscall_len</span>;

    vdso32_pages[0] = virt_to_page(syscall_page);

<span style="color: #7a378b;">#ifdef</span> CONFIG_X86_32
    gate_vma_init();
<span style="color: #7a378b;">#endif</span>

    <span style="color: #a020f0;">if</span> (vdso32_syscall()) {
        vsyscall = &amp;vdso32_syscall_start;
        vsyscall_len = &amp;vdso32_syscall_end - &amp;vdso32_syscall_start;
    } <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (vdso32_sysenter()){
        vsyscall = &amp;vdso32_sysenter_start;
        vsyscall_len = &amp;vdso32_sysenter_end - &amp;vdso32_sysenter_start;
    } <span style="color: #a020f0;">else</span> {
        vsyscall = &amp;vdso32_int80_start;
        vsyscall_len = &amp;vdso32_int80_end - &amp;vdso32_int80_start;
    }

    memcpy(syscall_page, vsyscall, vsyscall_len);
    relocate_vdso(syscall_page);

    <span style="color: #a020f0;">return</span> 0;
}
</pre>
The implementation of the <code>sysenter</code> method is in
<a href="http://lxr.linux.no/#linux+v2.6.32/arch/x86/vdso/vdso32/sysenter.S"><code>arch/x86/vdso/vdso32/sysenter.S</code></a>. The routine called by the libc
(with the <code>call *%gs:0x10</code>) is named <code>__kernel_vsyscall</code>:
<br />
<pre>  <span style="color: #a020f0;">__kernel_vsyscall</span>:
  <span style="color: #a020f0;">.LSTART_vsyscall</span>:
      <span style="color: #a020f0;">push</span> <span style="color: sienna;">%ecx</span>
  <span style="color: #a020f0;">.Lpush_ecx</span>:
      <span style="color: #a020f0;">push</span> <span style="color: sienna;">%edx</span>
  <span style="color: #a020f0;">.Lpush_edx</span>:
      <span style="color: #a020f0;">push</span> <span style="color: sienna;">%ebp</span>
  <span style="color: #a020f0;">.Lenter_kernel</span>:
      <span style="color: #a020f0;">movl</span> <span style="color: sienna;">%esp</span>,<span style="color: sienna;">%ebp</span>
      <span style="color: #a020f0;">sysenter</span>
    <span style="color: firebrick;">/* </span><span style="color: firebrick;">7: align return point with nop's to make disassembly easier */</span>
    <span style="color: #a020f0;">.space</span> 7,0x90

    <span style="color: firebrick;">/* </span><span style="color: firebrick;">14: System call restart point is here! (SYSENTER_RETURN-2) */</span>
    <span style="color: #a020f0;">jmp</span> .Lenter_kernel
    <span style="color: firebrick;">/* </span><span style="color: firebrick;">16: System call normal return point is here! */</span>
<span style="color: blue;">VDSO32_SYSENTER_RETURN</span>: <span style="color: firebrick;">/* </span><span style="color: firebrick;">Symbol used by sysenter.c via vdso32-syms.h */</span>
    <span style="color: #a020f0;">pop</span> <span style="color: sienna;">%ebp</span>
<span style="color: blue;">.Lpop_ebp</span>:
    <span style="color: #a020f0;">pop</span> <span style="color: sienna;">%edx</span>
<span style="color: blue;">.Lpop_edx</span>:
    <span style="color: #a020f0;">pop</span> <span style="color: sienna;">%ecx</span>
<span style="color: blue;">.Lpop_ecx</span>:
    <span style="color: #a020f0;">ret</span>
</pre>
Linus Torvalds is the proud owner of this code because he managed to
handle the system call restarting thanks to a CPU particularity:
when the kernel is done with a system call and want to give the
control back to the process, it just have to perform the <code>sysexit</code>
instruction. 
<br />
Prior to that, the kernel specified to the CPU that at <code>sysexit</code>,
it has to jump to a specific static address. This address is the
<code>VDSO32_SYSENTER_RETURN</code> label saw in the previous routine.</div>

